>本文学习的代码地址：[https://github.com/Snailclimb/guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework)
>本文代码地址：[https://gitee.com/uamaa/msc-rpc-framework](https://gitee.com/uamaa/msc-rpc-framework)

[TOC]

# 0.实现的改进
利用zookeeper实现注册中心：

- 客户端可以通过注册中心获取所需服务的服务提供方IP地址列表；（可改进：客户端通过负载均衡选择某一服务提供者来调用）
- 客户端可以通过注册中心监听所需服务节点，当节点发生变化时（如有服务提供方上线或下线），Zookeeper会通知客户端，客户端刷新本地服务提供方信息缓存
- 服务路径（`/my-rpc/{serviceName}  `）是永久节点，服务提供方地址（`/my-rpc/{serviceName}/{host}:{port}`）是临时节点，这样当有主机下线时，临时节点就会被删除。
- 动态感知服务器状态：当服务器启动时，会建立一个带有服务器地址的临时节点；当服务器下线时，该临时节点会因连接断开而删除，这样就做到了服务的自动下线与自动扩容上线。

# 1 Zookeeper
>这部分内容转载自：[Zookeeper 入门看这篇就够了](https://my.oschina.net/u/3796575/blog/1845035)
## 1.1 什么是Zookeeper？
Zookeeper是一个分布式服务框架，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。

**上面的解释有点抽象，简单来说 zookeeper = 文件系统 + 监听通知机制。**

**1、 文件系统**

Zookeeper 维护一个类似文件系统的数据结构：

![img](https://msc111.oss-cn-chengdu.aliyuncs.com/img/202205151607605.jpeg)
每个子目录项如 NameService 都被称作为 znode (目录节点)，和文件系统一样，我们能够自由的增加、删除 znode，在一个 znode 下增加、删除子 znode，唯一的不同在于 znode 是可以存储数据的。

有四种类型的 znode：

- **PERSISTENT - 持久化目录节点**
客户端与 zookeeper 断开连接后，该节点依旧存在
- **PERSISTENT_SEQUENTIAL - 持久化顺序编号目录节点**
客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号
- **EPHEMERAL - 临时目录节点**
客户端与 zookeeper 断开连接后，该节点被删除
- **EPHEMERAL_SEQUENTIAL - 临时顺序编号目录节点**
客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号

**2、 监听通知机制**

客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper 会通知客户端。

就这么简单，下面我们看看 Zookeeper 能做点什么呢？
## 1.2 Zookeeper 能做什么
zookeeper 功能非常强大，可以实现诸如分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。


假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到 zookeeper 上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e4ee757df8f64bb1aa76993dd857a14f.png)
## 1.3 使用Zookeeper
1.官网下载：[https://zookeeper.apache.org/releases.html](https://zookeeper.apache.org/releases.html)
![在这里插入图片描述](https://img-blog.csdnimg.cn/354230cca92b4c919ffe27bfdcb10447.png)
我下载的是第一种，第二种会出错我不知道为什么
2.IDEA添加Zookeeper依赖
IDEA还可以添加Zookeeper插件，我还是会出错（小倒霉蛋）
3.测试
>**以下代码出自：[ZooKeeper入门，看这篇就够了](https://developer.aliyun.com/article/771662)**

```java
public class ZkTest{

    //连接地址及端口号
    private static final String SERVER_HOST = "127.0.0.1:2181";

    //会话超时时间
    private static final int SESSION_TIME_OUT = 2000;

    public static void main(String[] args) throws Exception {
        //参数一：服务端地址及端口号
        //参数二：超时时间
        //参数三：监听器
        ZooKeeper zooKeeper = new ZooKeeper(SERVER_HOST, SESSION_TIME_OUT, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                //获取事件的状态
                Event.KeeperState state = watchedEvent.getState();
                //判断是否是连接事件
                if (Event.KeeperState.SyncConnected == state) {
                    Event.EventType type = watchedEvent.getType();
                    if (Event.EventType.None == type) {
                        System.out.println("zk客户端已连接...");
                    }
                }
            }
        });
        zooKeeper.create("/java", "Hello World".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        System.out.println("新增ZNode成功");
        zooKeeper.close();
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/ddb56e89daa44231a214da076d78561e.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/236e51ceabcb4acfb40175b34d832d11.png)
客户端能看到
（本来zookeeper插件也能看到的，但是我插件有问题quq）

# 2 用Zookeeper实现注册中心
## 2.1 注册中心的业务逻辑
>内容来自：《架构探险：从零开始写分布式服务架构》

**服务端服务的注册**：服务的服务端服务启动的同时，将服务提供者信息（主机IP地址、服务端口、服务接口类路径）组成的znode路径写入ZooKeeper 中，**注意写入的叶子节点为临时节点**。这样就完成了服务的注册动作。

**客户端服务的发现与调用**：服务的消费端在发起服务调用之前，会先连接到ZooKeeper，对服务提供者节点路径**注册监听器**，同时获取服务提供者信息到**本地缓存**，发起调用的时候，调用者会从服务提供者本地缓存列表中运用某种负载均衡策略选取某一个服务提供者，对该服务提供者发起调用，最终完成本次服务调用。这样就完成了服务发现动作。

**服务的自动下线与自动扩容上线**：若服务提供者集群中某台机器下线，该机器与注册中心ZooKeeper 的连接会断掉，因为服务注册写入信息的叶子节点写入的znode是临时节点。故当与ZooKeeper连接断掉后，该临时节点会被自动删除。同时触发服务消费端对服务提供者路径的监听器，服务消费端收到被删除服务提供者节点信息之后，刷新本地服务提供者信息缓存，从缓存中删除已下线的服务提供者信息。这样就做到了服务的自动下线。同理，服务提供者集群新增机器，会在服务提供者znode下新增临时叶子节点，同时触发服务消费端对服务提供者路径的监听器，服务消费端收到新增服务提供者节点信息之后，刷新本地服务提供者信息缓存，将新加入的服务提供者信息加入服务提供者信息本地缓存中。这样就做到了服务的自动扩容上线。

## 2.2 集成ZooKeeper 实现自己的服务注册与发现
这里实际实现逻辑与书中不太一样，主要是利用Zookeeper实现了：

1. 服务端发送IP、端口号、服务路径给注册中心来实现注册服务；

2. 客户端通过注册中心得到所需服务的服务提供者地址；并保存在本地缓存；并对该服务注册监听，如果有变动，将变动修改回本地缓存；



以前的逻辑是：

- 服务端手动将服务注册到注册中心（将接口名与服务存到Map里），并开启指定端口的监听
- 客户端连接指定端口，并向其发送RpcRequest
- 服务端收到RpcRequest后，根据RpcRequest里的接口名从Map中取出对应服务，调用该服务后将数据封装成RpcResponse返回给客户端
- 客户端从RpcResponse中取出调用数据，调用完成；

利用Zookeeper实现注册中心后的逻辑是：

- 服务端把自己的IP，端口，服务路径给注册中心注册，并将接口名与服务存到Map里
- 客户端通过zookeeper注册中心得到所需服务的服务端的地址，向其发送RpcRequest；并监听该节点；
- 服务端收到RpcRequest后，根据RpcRequest里的接口名从Map中取出对应服务，调用该服务后将数据封装成RpcResponse返回给客户端
- 客户端从RpcResponse中取出调用数据，调用完成；



### 2.2.1 服务的注册

服务的注册就是将服务路径和IP地址注册到Zookeeper节点中，格式如下：` /my-rpc/{serviceName}/{host}:{port} `

其中：`/my-rpc/{serviceName}  `是永久节点，`/my-rpc/{serviceName}/{host}:{port}`是临时节点，这样当有主机下线时，临时节点就会被删除。

`CuratorHelper`提供`createPersistentNode`和`createEphemeralNode`方法

> 代码来自：[【RPC】 ---- 基于ZooKeeper为注册中心实现的RPC](https://blog.csdn.net/whc__/article/details/117938626)

```java
/**
 * @Description 根据节点路径创建临时节点 临时节点存储在zookeeper中，当断开连接时被删除
 * @param zkClient  与zookeeper服务器连接的zookeeper客户端
 * @param path      节点路径
 */
public static void createEphemeralNode(final CuratorFramework zkClient, final String path) {
    try {
        // 临时节点已存在
        if (EPHEMERAL_REGISTERED_PATH_SET.contains(path) || zkClient.checkExists().forPath(path) != null) {
            log.info("临时节点已经存在,临时节点是:[{}]", path);
        } else {
            // 临时节点不存在,则创建临时节点
            //eg: /MyRPC/com.whc.rpc.api.UserService/127.0.0.1:9000
            zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path);
            log.info("临时节点成功被创建,临时节点是:[{}]", path);
        }
        EPHEMERAL_REGISTERED_PATH_SET.add(path);
    } catch (Exception e) {
        log.error("创建临时节点失败[{}]", path);
    }
}

// 创建服务名永久节点PERSISTENT
public static void createPersistentNode(CuratorFramework zkClient, String path) {
    try {
        // 永久节点已存在
        if (PERSISTENT_REGISTERED_PATH_SET.contains(path) || zkClient.checkExists().forPath(path) != null) {
            log.info("永久节点已经存在,永久节点是:[{}]", path);
        } else {
            // 永久节点不存在,则创建永久节点
            //eg: /MyRPC/com.whc.rpc.api.UserService
            zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(path);
            log.info("永久节点成功被创建,永久节点是:[{}]", path);
        }
        PERSISTENT_REGISTERED_PATH_SET.add(path);
    } catch (Exception e) {
        log.error("创建永久节点失败[{}]", path);
    }
}
```

### 2.2.2 服务的发现

根据服务名获取Zookeeper中的IP地址

```java
/**
 * @Description         根据服务名获取节点中的内容
 * @param zkClient      与zookeeper服务器连接的zookeeper客户端
 * @param serviceName   服务名称
 */
public static List<String> getChildrenNodes(final CuratorFramework zkClient, final String serviceName) {
    if (SERVICE_ADDRESS_MAP.containsKey(serviceName)) {
        return SERVICE_ADDRESS_MAP.get(serviceName);
    }
    List<String> result = Collections.emptyList();
    String servicePath = CuratorHelper.ZK_REGISTER_ROOT_PATH + "/" + serviceName;
    try {
        result = zkClient.getChildren().forPath(servicePath);
        SERVICE_ADDRESS_MAP.put(serviceName, result);
        registerWatcher(zkClient, serviceName);
    } catch (Exception e) {
        log.error("getChildrenNodes occur exception:", e);
    }
    return result;
}
```



# 3.学到的知识

1.一定要记笔记，不然面试的时候就忘干净了！现在相当于是把记忆备份，等面试的时候好回顾
2.先搞懂本次修改的主体逻辑，再看细枝末节的地方
3.多看书，增加视野
4.注释对齐，看着好巴适哦
![在这里插入图片描述](https://img-blog.csdnimg.cn/eeba214273a94c358fa46d27737227d2.png)
5.竖向一起修改属性名：shift+f6(+fn)
6.外网资料丰富一点，有问题多到外网找。
