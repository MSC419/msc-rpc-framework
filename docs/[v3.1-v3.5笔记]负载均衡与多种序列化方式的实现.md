> 本文代码地址：[https://gitee.com/uamaa/msc-rpc-framework](https://gitee.com/uamaa/msc-rpc-framework)

[TOC]

# 0.实现的改进

1.支持服务端暴露多个服务接口

2.自定义协议通信，使之支持多种消息类型、序列化方式(Json、Hessian、Kryo)

3.使用Netty的拆包器解决粘包问题

4.客户端实现负载均衡策略

5.用多种序列化方式实现序列化

# 1.支持服务端暴露多个服务接口

实现方式很简单：之前是服务端`NettyServer`在注册完一个接口之后立即启动Netty连接`start()`，现在是服务端注册完所有接口之后再启动Netty连接

# 2.自定义协议通信

## 2.1 通信协议设计

> 参考：https://www.cnblogs.com/caoweixiong/p/14663492.html

所谓的协议，就是通信双方事先商量好的接口“暗语”， 在 TCP 网络编程中，发送方和接收方的数据包格式都是二进制，

发送方将对象转化成二进制流发送给接收方，接收方获得二进制数据后需要知道如何解析对象，所以协议是双方能够正常通行的基础。



一个较为通用的协议示例：

```
+---------------------------------------------------------------+
| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte |
+---------------------------------------------------------------+
| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | 
+---------------------------------------------------------------+
|                   数据内容 （长度不定）                          |
+---------------------------------------------------------------+
```

#### 1. 魔数

魔数是通信双方协商的一个暗号，通常采用固定的几个字节表示。魔数的作用是**防止任何人随便向服务器的端口上发送数据**。服务端在接收到数据时会解析出前几个固定字节的魔数，然后做正确性比对。如果和约定的魔数不匹配，则认为是非法数据，可以直接关闭连接或者采取其他措施以增强系统的安全防护。魔数的思想在压缩算法、Java Class 文件等场景中都有所体现，例如 Class 文件开头就存储了魔数 0xCAFEBABE，在加载 Class 文件时首先会验证魔数的正确性。

#### 2. 协议版本号

随着业务需求的变化，协议可能需要对结构或字段进行改动，不同版本的协议对应的解析方法也是不同的。所以在生产级项目中强烈建议预留**协议版本号**这个字段。

#### 3. 序列化算法

序列化算法字段表示数据发送方应该采用何种方法将请求的对象转化为二进制，以及如何再将二进制转化为对象，如 JSON、Hessian、Java 自带序列化等。

#### 4. 报文类型

在不同的业务场景中，报文可能存在不同的类型。例如在 RPC 框架中有请求、响应、心跳等类型的报文，在 IM 即时通信的场景中有登陆、创建群聊、发送消息、接收消息、退出群聊等类型的报文。

#### 5. 长度域字段

长度域字段代表**请求数据**的长度，接收方根据长度域字段获取一个完整的报文。

#### 6. 请求数据

请求数据通常为序列化之后得到的**二进制流**，每种请求数据的内容是不一样的。

#### 7. 状态

状态字段用于标识**请求是否正常**。一般由被调用方设置。例如一次 RPC 调用失败，状态字段可被服务提供方设置为异常状态。

#### 8. 保留字段

保留字段是可选项，为了应对协议升级的可能性，可以预留若干字节的保留字段，以备不时之需。

## 2.2 Netty实现自定义通信协议

在RPC中，RpcRequest和RpcResponse通过编码，从POJO对象变为二进制对象在网络中传播，再通过解码从二进制对象变成POJO对象被进一步处理。现在我们设计好了通信协议，在编码的时候把通信协议头信息添加上去，在解码的时候按照通信协议解码数据

通信协议简化了一下：

```
+---------------------------------------------------------------+
| 魔数 4byte | 序列化算法 1byte | 报文类型 1byte |  数据长度 4byte  |
+---------------------------------------------------------------+
|                   数据内容 （长度不定）                          |
+---------------------------------------------------------------+
```

### 编码器

```java
@Slf4j
public class NettyEncoder extends MessageToByteEncoder {
    private static final int MAGIC_NUMBER = 0xCAFEBABE;

    private final Serializer serializer;

    public NettyEncoder(Serializer serializer) {
        this.serializer = serializer;
    }

    /**
     * 通信协议头：
     * +---------------------------------------------------------------+
     * | 魔数 4byte | 序列化算法 1byte | 报文类型 1byte |  数据长度 4byte  |
     * +---------------------------------------------------------------+
     * |                   数据内容 （长度不定）                          |
     * +---------------------------------------------------------------+
     */
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
        try {
            //魔数
            out.writeInt(MAGIC_NUMBER);
            //序列化算法
            out.writeByte(serializer.getCode());
            //报文类型
            if (msg instanceof RpcRequest) {
                out.writeByte(PackageType.REQUEST_PACK.getCode());
            } else {
                out.writeByte(PackageType.RESPONSE_PACK.getCode());
            }
            // 1. 将对象转换为byte
            byte[] bytes = serializer.serialize(msg);
            // 2. 写入消息对应的字节数组长度
            out.writeInt(bytes.length);
            // 3. 将字节数组写入 ByteBuf 对象中
            out.writeBytes(bytes);
        }catch (Exception e){
            log.error("Netty Encode error!", e);
        }
    }
}
```

###  解码器

```java
@Slf4j
public class NettyDecoder extends ByteToMessageDecoder {
    private static final int MAGIC_NUMBER = 0xCAFEBABE;
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        try{
            //魔数是否匹配
            int magic = in.readInt();
            if(magic != MAGIC_NUMBER) {
                log.error("不识别的协议包:{}", magic);
                throw new RpcException(RpcErrorMessageEnum.UNKNOWN_PROTOCOL);
            }
            //序列化算法
            byte serializerCode = in.readByte();
            Serializer serializer = Serializer.getByCode(serializerCode);
            if(serializer == null) {
                log.error("不识别的反序列化器:{}", serializerCode);
                throw new RpcException(RpcErrorMessageEnum.UNKNOWN_SERIALIZER);
            }
            //报文类型
            byte packageCode = in.readByte();
            Class<?> packageClass;
            if(packageCode == PackageType.REQUEST_PACK.getCode()) {
                packageClass = RpcRequest.class;
            } else if(packageCode == PackageType.RESPONSE_PACK.getCode()) {
                packageClass = RpcResponse.class;
            } else {
                log.error("不识别的数据包:{}", packageCode);
                throw new RpcException(RpcErrorMessageEnum.UNKNOWN_PACKAGE_TYPE);
            }

            // 数据长度
            int length = in.readInt();
            byte[] bytes = new byte[length];
            // 填充数据
            in.readBytes(bytes);
            // 反序列化
            Object obj = serializer.deserialize(bytes, packageClass);
            out.add(obj);
        }catch (Exception e){
            log.error("Netty Decoder error!",e);
        }

    }
}
```

# 3.使用Netty的半包解码器解决粘包问题

## 3.1 TCP粘包/拆包

TCP是个“流”协议，就像河里的流水一样，数据连成一片，没有分界线。TCP底层并不了解上层数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分。所以在业务上认为，一个完整的包可能被TCP分成多个包发送，或者把多个小包封装成一个大的数据包发送。这就是TCP的粘包和拆包问题。

## 3.2 Netty解决粘包/拆包问题

解决思路：在接收端，根据**自定义协议**来读取底层的数据包。每次读取完，判断是否为一个完整的应用层数据包。如果是，上层应用层数据包读取完成。如果不是，那就保留该数据在应用层缓冲区，然后继续从 TCP 缓冲区中读取，直到得到一个完整的应用层数据包为止。



Netty常用的半包解码器解决粘包拆包问题

- `LengthFieldBasedFrameDecoder`：基于长度域的半包解码器
- `LineBasedFrameDecoder`：行半包解码器
- `DelimiterBasedFrameDecoder`：基于分隔符半包解码器
- `FixedLengthFrameDecoder`：定长半包解码器



```java
/**
 * @Description 用于解决粘包/拆包问题
 * @Author MSC419
 * @Date 2022/5/16 19:32
 * @Version 1.0
 */
public class Spliter extends LengthFieldBasedFrameDecoder {
    private static final int MAGIC_NUMBER = 0xCAFEBABE;

    /**
     * 通信协议格式：
     * +---------------------------------------------------------------+
     * | 魔数 4byte | 序列化算法 1byte | 报文类型 1byte |  数据长度 4byte   |
     * +---------------------------------------------------------------+
     * |                   数据内容 （长度不定）                          |
     * +---------------------------------------------------------------+
     */
    private static final int LENGTH_FIELD_OFFSET = 6;
    // 数据长度
    private static final int LENGTH_FIELD_LENGTH = 4;

    public Spliter() {
        super(Integer.MAX_VALUE, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH);
    }

    @Override
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        if(in.getInt(in.readerIndex()) != MAGIC_NUMBER) {
            ctx.channel().closeFuture();
            return null;
        }
        return super.decode(ctx, in);
    }
}
```

将解决粘包/拆包问题的Spliter放入Netty服务端与客户端的ChannelPipeline中即可

![image-20220516194745359](https://msc111.oss-cn-chengdu.aliyuncs.com/img/202205161947582.png)

# 4.客户端实现负载均衡策略

> 参考：《架构探险：从零开始写分布式服务架构》

负载均衡常用算法主要有随机、加权随机、轮询、加权轮询、源地址 hash等。

**随机**：获得服务提供者列表大小区间之间的随机数，作为服务提供者列表的索引来获取服务。

**加权随机**：首先根据加权数放大服务提供者列表，比如服务提供者A加权数为3，放大之后变为 A，A，A，存放在新的服务提供者列表，然后对新的服务提供者列表应用随机算法。

**轮询**：依次按顺序获取服务提供者列表中的数据，并使用计数器记录使用过的数据索引，若数据索引到最后一个数据，则计数器归零，重新开始新的循环。

**加权轮询**：首先根据加权数放大服务提供者列表，再在放大后的服务提供者基础上使用轮询算法获取服务提供者。

**源地址hash**：使用调用方IP地址的hash值，将服务列表大小取模后的值作为服务列表索引，根据该索引取值。

```java
public interface LoadBalancer {
    String balance(List<String> addressList);
}
```

```java
public class RandomLoadBalance implements LoadBalancer{
    @Override
    public String balance(List<String> addressList) {
        return addressList.get(new Random().nextInt(addressList.size()));
    }
}
```

```java
public class RoundLoadBalance implements LoadBalancer{
    private int index = 0;
    @Override
    public String balance(List<String> addressList) {
        if(index>=addressList.size()){
            index %= addressList.size();
        }
        return addressList.get(index++);
    }
}
```



![image-20220516203740771](https://msc111.oss-cn-chengdu.aliyuncs.com/img/202205162037781.png)

![image-20220516203819026](https://msc111.oss-cn-chengdu.aliyuncs.com/img/202205162038942.png)

# 5.多种序列化方式实现序列化

之前我们已经将序列化抽象成接口，并且用Kryo实现了序列化功能，这次增加两种实现序列化功能的方式：Json、Hessian

# 6.总结

## 6.1 学到的知识

1.[从0开始，实现一个简单的RPC框架](https://github.com/TheWhc/MyRpc) 从这个项目里学到：（1）要写简介清晰的README来介绍自己的项目；（2）每一个版本更替都写一个笔记，方便读者阅读与自己回顾

2.Markdown行内代码块快捷键：CTRL+Shift+`

多行代码快捷键：Ctrl+Shift+K

