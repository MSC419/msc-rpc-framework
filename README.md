# 版本1：基于BIO实现RPC

## 优点

- 将消息封装成通用消息格式（RpcRequest、RpcResponse），同时定义了枚举类RpcResponseCode供RpcResponse附着调用成功与否信息
- 服务抽象成接口，方便以后服务扩展
- 自定义异常类，根据自己业务的异常情况细化异常。同时定义了异常解释枚举类供自定义异常类调用
- 客户端通过动态代理完成对RpcRequest消息格式的封装与对远程服务的调用

## 缺点

- 传统的BIO与线程池网络传输性能低

## TODO

- 本版本实现了线程池版的服务端的实现，但是线程池我还不是很熟悉，等以后熟悉了再反过来看看这一段代码（或者再改进一下）
- 用Netty实现网络传输
- 用多种序列化方式实现序列化
- 实现一个服务端提供多个服务接口

# 版本2：基于Netty实现RPC

## 优点

- 利用Netty实现网络传输
- 利用Kryo实现序列化与反序列化，提高了序列化效率

## 缺点

- 客户端必须预先知道其所需服务的服务提供者的host和port

## TODO

- 自定义协议通信，使之支持多种消息类型、序列化方式(Json、Hessian、Kryo)
- 使用Netty的半包解码器解决粘包问题

- 利用zookeeper完成服务器的注册与发现，实现注册中心功能
- 客户端负载均衡策略的实现

# 版本3：基于Zookeeper实现注册中心

## 优点：

- 支持服务端暴露多个接口与接口实现类服务
- 自定义协议通信，使之支持多种消息类型、序列化方式(Json、Hessian、Kryo)
- 使用Netty的半包解码器解决粘包问题
- 利用zookeeper完成服务器的注册与发现，实现注册中心功能
- 客户端负载均衡策略的实现

## 缺点
- 服务端需要手动注册服务

## TODO
- 增加 Netty 心跳机制
- 通过注解自动扫描注册服务

# 版本4：通过注解自动扫描注册服务

## 优点

- 实现了注解自动扫描注册服务
- 将RPC消息统一成RpcMessage
- 实现了 Netty 心跳机制，确保长连接有效

## TODO

- 增加SPI机制
- 增加数据压缩方式
- 增加自定义协议相关配置

